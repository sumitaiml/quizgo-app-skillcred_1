# quiz_generator.py - Google AI Powered Quiz Generator (Complete & Corrected)
import requests
import os
from dotenv import load_dotenv
import PyPDF2

# Load your secret tokens
load_dotenv()

def extract_text_from_pdf(pdf_path):
    """Get text from your PDF file"""
    try:
        with open(pdf_path, 'rb') as file:
            pdf_reader = PyPDF2.PdfReader(file)
            text = ""
            
            for page_num in range(len(pdf_reader.pages)):
                page = pdf_reader.pages[page_num]
                text += page.extract_text() + "\n"
            
            return text.strip()
    except Exception as e:
        print(f"❌ Error reading PDF: {e}")
        return None

def generate_quiz_with_google_ai(pdf_text):
    """Use Google AI Studio (Gemini) for quiz generation - CORRECTED VERSION"""
    
    # Get Google API key from .env file
    api_key = os.getenv("GOOGLE_API_KEY")
    
    if not api_key:
        print("❌ No Google API key found! Check your .env file")
        return None
    
    print(f"✅ Google API Key loaded: {api_key[:10]}...")
    
    # CORRECTED Google AI Studio endpoint with proper model name
    url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={api_key}"
    
    headers = {
        "Content-Type": "application/json"
    }
    
    # Create educational prompt
    prompt = f"""You are an expert educational content creator. Based on this database serializability content, create exactly 3 high-quality multiple choice questions suitable for university students.

Content: {pdf_text[:1000]}

Requirements:
- Each question should test understanding, not just memorization
- Include 4 options (A, B, C, D) with only one correct answer
- Add brief explanations for the correct answers
- Focus on key concepts like conflict serializability, precedence graphs, and view serializability

Format each question exactly like this:
Q1. [Question text]
A) [Option A]
B) [Option B]
C) [Option C]
D) [Option D]
Answer: [Correct letter]
Explanation: [Brief explanation]

Generate exactly 3 questions following this format."""

    data = {
        "contents": [{
            "parts": [{
                "text": prompt
            }]
        }],
        "generationConfig": {
            "temperature": 0.7,
            "candidateCount": 1,
            "maxOutputTokens": 1000
        }
    }
    
    try:
        print("🤖 Generating questions with Google AI (Gemini 1.5 Flash)...")
        response = requests.post(url, headers=headers, json=data, timeout=30)
        
        print(f"Response status: {response.status_code}")
        
        if response.status_code == 200:
            result = response.json()
            if 'candidates' in result and len(result['candidates']) > 0:
                generated_text = result['candidates'][0]['content']['parts'][0]['text']
                return generated_text
            else:
                print("❌ No content generated by Google AI")
                return None
        else:
            print(f"❌ Google AI Error: {response.status_code}")
            print(f"Response: {response.text}")
            return None
            
    except Exception as e:
        print(f"❌ Connection error: {e}")
        return None

def generate_backup_quiz(pdf_text):
    """Backup method - content-based generation"""
    questions = [
        """Q1. What is the main purpose of conflict serializability in database systems?
A) To prevent network conflicts between users
B) To ensure concurrent transaction schedules produce the same result as serial execution
C) To serialize data into JSON format for storage
D) To create backup copies of database transactions
Answer: B
Explanation: Conflict serializability ensures that concurrent transactions produce the same final database state as if executed serially.""",

        """Q2. In testing for conflict serializability, what does a cycle in the precedence graph indicate?
A) The schedule is serializable
B) The schedule is not conflict serializable
C) The database needs optimization
D) Transactions are running too slowly
Answer: B
Explanation: A cycle in the precedence graph indicates conflicting operations that create circular dependencies, making the schedule non-serializable.""",

        """Q3. How does view serializability differ from conflict serializability?
A) View serializability is more restrictive than conflict serializability
B) They are exactly the same concept
C) View serializability is less restrictive and allows more schedules to be considered serializable
D) View serializability only applies to read operations
Answer: C
Explanation: View serializability considers schedules serializable if they are view equivalent to some serial schedule, allowing more schedules than conflict serializability."""
    ]
    return questions

def main():
    """Main function - runs your Google AI Quiz Generator"""
    print("🎓 Welcome to your GOOGLE AI Quiz Generator!")
    print("🚀 Now powered by Google Gemini AI!")
    print("=" * 60)
    
    # Your PDF file name
    pdf_file = "Questions_on_Conflict_Serailizability[1].pdf"
    
    # Step 1: Extract text from PDF
    print("📄 Step 1: Reading your PDF...")
    pdf_text = extract_text_from_pdf(pdf_file)
    
    if not pdf_text:
        print("❌ Could not read PDF file")
        return
    
    print(f"✅ Extracted {len(pdf_text)} characters from PDF")
    print("📖 Content preview:")
    print(pdf_text[:300] + "...")
    
    # Step 2: Try Google AI first
    print("\n🤖 Step 2: Using Google AI (Gemini) for quiz generation...")
    ai_questions = generate_quiz_with_google_ai(pdf_text)
    
    if ai_questions:
        print("\n" + "=" * 60)
        print("🎉 GOOGLE AI GENERATED QUIZ QUESTIONS:")
        print("=" * 60)
        print(ai_questions)
        print("=" * 60)
        print("✅ Google AI generation successful! Questions ready for classroom use!")
    else:
        print("\n🔄 Google AI not available, using proven backup method...")
        backup_questions = generate_backup_quiz(pdf_text)
        
        print("\n" + "=" * 60)
        print("📝 CONTENT-BASED QUIZ QUESTIONS:")
        print("=" * 60)
        
        for i, question in enumerate(backup_questions, 1):
            print(f"\n{question}")
        
        print("\n" + "=" * 60)
        print("✅ Quiz generation complete using reliable backup system!")
    
    print("\n💡 Your Quiz Generator now uses Google's powerful Gemini AI!")

if __name__ == "__main__":
    main()

